## 풀이 날짜
2023-08-04

## 문제
https://school.programmers.co.kr/learn/courses/30/lessons/42898

## 막혔던 부분
1. **물 웅덩이 좌표가 반대인 문제**  
그림에서는 `m = x` 에 해당하고, `n = y` 에 해당해서 `(x, y)` 순서로 좌표를 표현하지만
`puddles` 는 반대로 `(y, x)` 순서로 좌표를 표현하고 있어서 혼란스러웠다.  
심지어 테스트 케이스로 `(2, 2)` 웅덩이가 있어서 더욱 헷갈렸다.  
2. **모듈러 연산 효율 문제**  
처음에는 `dp[j][i] = dp[j - 1][i] + dp[j][i - 1]` 점화식을 사용하고 마지막에 모듈러 연산을 했었는데 효율성 체크를 통과하지 못했었다.  
그래서 `dp[j][i] = (dp[j - 1][i] + dp[j][i - 1]) % 1000000007` 로 교체했는데 통과하게 되었다.

## 아이디어
`dp[y][x]` 는 `(y, x)` 까지 도달하는 경우의 수를 표현한다.  

1. `(y, x)` 좌표까지 도달하는 경우의 수를 기록하는 2차원 배열 `dp` 의 모든 원소를 `0` 으로 초기화한다.  
2. 물 웅덩이가 존재하는 좌표는 `-1` 값으로 초기화한다.
3. `(1, 1)` 좌표를 기준으로 오른쪽과 아래쪽 방면은 경우의 수가 1이니 `1` 로 초기화한다.  
4. `(2, 2)` 좌표부터 `(n, m)` 좌표까지 순회한다:  
    1. 만약 현재 `(j, i)` 좌표가 물 웅덩이라면 스킵한다.  
    2. 현재 좌표를 기준으로 왼쪽 좌표 혹은 위쪽 좌표가 물 웅덩이라면, 둘 중에서 물 웅덩이가 아닌 값을 그대로 사용한다.  
    3. 현재 좌표를 기준으로 왼쪽 좌표와 위쪽 좌표 모두 물 웅덩이가 아니라면, 두 값을 더한 뒤 `1000000007` 로 나머지 연산을 한다.  
5. `dp[n][m]` 를 반환한다.  

## 소스코드
```js
function solution(m, n, puddles) {
  const dp = Array.from({ length: n + 1 }, () => Array.from({ length: m + 1 }).fill(0));

  puddles.forEach(([x, y]) => {
    dp[y][x] = -1;
  });

  for (let i = 1; i <= m; i++) {
    if (dp[1][i] === -1) break;
    dp[1][i] = 1;
  }

  for (let i = 1; i <= n; i++) {
    if (dp[i][1] === -1) break;
    dp[i][1] = 1;
  }

  for (let i = 2; i <= m; i++) {
    for (let j = 2; j <= n; j++) {
      if (dp[j][i] === -1) continue;

      if (dp[j - 1][i] === -1 || dp[j][i - 1] === -1) {
        dp[j][i] = Math.max(dp[j - 1][i], dp[j][i - 1]);
      } else {
        dp[j][i] = (dp[j - 1][i] + dp[j][i - 1]) % 1000000007;
      }
    }
  }

  return dp[n][m];
}
```