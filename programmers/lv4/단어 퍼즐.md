## 풀이 날짜
2023-06-13

## 문제
https://school.programmers.co.kr/learn/courses/30/lessons/12983

### 문제 설명
단어 퍼즐은 주어진 단어 조각들을 이용해서 주어진 문장을 완성하는 퍼즐입니다. 이때, 주어진 각 단어 조각들은 각각 무한개씩 있다고 가정합니다. 예를 들어 주어진 단어 조각이 [“ba”, “na”, “n”, “a”]인 경우 "ba", "na", "n", "a" 단어 조각이 각각 무한개씩 있습니다. 이때, 만들어야 하는 문장이 “banana”라면 “ba”, “na”, “n”, “a”의 4개를 사용하여 문장을 완성할 수 있지만, “ba”, “na”, “na”의 3개만을 사용해도 “banana”를 완성할 수 있습니다. 사용 가능한 단어 조각들을 담고 있는 배열 strs와 완성해야 하는 문자열 t가 매개변수로 주어질 때, 주어진 문장을 완성하기 위해 사용해야 하는 단어조각 개수의 최솟값을 return 하도록 solution 함수를 완성해 주세요. 만약 주어진 문장을 완성하는 것이 불가능하면 -1을 return 하세요.

제한사항
strs는 사용 가능한 단어 조각들이 들어있는 배열로, 길이는 1 이상 100 이하입니다.
strs의 각 원소는 사용 가능한 단어조각들이 중복 없이 들어있습니다.
사용 가능한 단어 조각들은 문자열 형태이며, 모든 단어 조각의 길이는 1 이상 5 이하입니다.
t는 완성해야 하는 문자열이며 길이는 1 이상 20,000 이하입니다.
모든 문자열은 알파벳 소문자로만 이루어져 있습니다.

## 어려웠던 점
전체 문자열 `t` 를 순서대로 순회하면서 값을 계산하고 저장하는 방식의 동적 계획법으로 풀어야 한다는 점은 알았으나 두 가지의 부분에서 막혔다.  
1. 현재 순회중인 문자열 `substr` 에서 어떻게 단어 사전에서 꺼낸 문자열 `str` 만 꺼낼 수 있을까? 문자열을 직접적으로 `substring` 으로 조작하면서 처리해야하나? 그렇다면 성능은 괜찮을까?
2. 현재 순회중인 문자열 `substr` 이 통째로 단어 사전에 들어있다면, 값은 그냥 `1` 을 넣어주면 된다. 그런데 그렇지 않은 경우라면 이전의 `dp` 값과 비교해야 하는데 수식을 어떻게 작성해야 할까?  

[여기](https://velog.io/@longroadhome/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-LV.4-%EB%8B%A8%EC%96%B4-%ED%8D%BC%EC%A6%90)에서 아이디어를 얻을 수 있었는데  

1. `substr.endsWith()` 메소드를 통해서 현재 순회중인 문자열 `substr` 가 현재 단어 사전에서 꺼낸 문자열 `str` 로 끝나는 경우에만 값을 계산하는 로직을 수행한다.  
그리고 `substr` 의 길이에서 `str` 의 길이를 빼면 현재 순회중인 문자열 `substr` 에서 단어 사전에서 꺼낸 문자열 `str` 가 시작하는 위치를 알 수 있으므로 그 부분을 단어 사전에 없는 부분과 있는 부분을 구분하는 포인터로 사용하여 `splitedAt` 변수에 저장한다.  
2. `dp` 배열에 저장할 값의 수식은 크게 두 가지로 나눈다.  
    - **현재 순회중인 문자열 `substr` 자체가 단어 사전에 들어있는 경우**  
    그냥 꺼내서 사용하면 되니, 값은 1이다. 즉, `dp[i] = 1`
    - **현재 순회중인 문자열 `substr` 의 뒷 부분만 단어 사전에 들어있는 경우**  
    (이전 문자열) + (단어 사전에 있는 부분) 의 두 부분으로 나눠야 한다.  
    이전 문자열 부분은 이전에 계산했던 `dp[splitedAt - 1]` 값을 사용하고, 단어 사전에 있는 부분은 꺼내서 쓰면 되니까 `1` 값을 사용하면 된다.  
    즉, `dp[i] = dp[diff - 1] + 1`  
    그런데 중요한 점은 현재 순회중인 문자열 `substr` 에 대해서 단어 사전에서 꺼내는 여러 경우의 수가 있을 수 있다는 점이다.  
    그렇기에 미리 계산했을지 모르는 `dp[i]` 값도 체크해봐야 한다.  
    즉, `dp[i] = Math.min(dp[i], dp[splitedAt - 1] + 1)`

## 아이디어
1. 전체 문자열 `t` 를 앞에서부터 순회하면서 로직을 수행한다.  
> 1. 현재 순회중인 위치까지 부분 문자열 `substr` 를 추출한다.  
> 2. `substr` 를 대상으로 단어 사전에 들어있는 모든 단어를 순회하면서 로직을 수행한다.  
> > 1. `substr` 이 단어 사전에서 꺼낸 문자 `str` 으로 끝나지 않는다면 스킵한다.  
> > 2. 단어 사전에서 꺼낸 문자 `str` 이 시작하는 위치를 `splitedAt` 에 저장한다.  
> > 3-1. 현재 순회중인 문자열 `substr` 자체가 단어 사전에 들어있는 경우라면 그냥 꺼내서 사용하면 되니 `dp[i] = 1` 를 저장한다.  
> > 3-2. 현재 순회중인 문자열 `substr` 의 뒷 부분만 단어 사전에 들어있는 경우라면 `dp[i] = Math.min(dp[i], dp[splitedAt - 1] + 1)` 를 저장한다.  

## 소스코드
```js{10-12}
function solution(strs, t) {
  const dp = Array.from({ length: t.length }, () => Infinity);

  for (let i = 0; i < t.length; i++) {
    const substr = t.substring(0, i + 1);

    for (const str of strs) {
      if (!substr.endsWith(str)) continue;

      const splitedAt = substr.length - str.length;
      if (splitedAt) dp[i] = Math.min(dp[i], dp[splitedAt - 1] + 1);
      else dp[i] = 1;
    }
  }

  return dp[t.length - 1] !== Infinity ? dp[t.length - 1] : -1;
}
```

## 참고자료
[[프로그래머스] LV.4 단어 퍼즐 (longroadhome)](https://velog.io/@longroadhome/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-LV.4-%EB%8B%A8%EC%96%B4-%ED%8D%BC%EC%A6%90)  